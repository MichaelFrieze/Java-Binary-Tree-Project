{
  "name": "Java-binary-tree-project",
  "tagline": "",
  "body": "# Project Team 7 - Binary Tree\r\n\r\n## Team Members\r\n- Serar Matloob\r\n- Michael Frieze\r\n- Tiantan Ma\r\n- Jesse Emelian\r\n\r\n\r\n## Project Objectives\r\n\r\n- Construct 3 Binary Tree Data Structures using key value pairs of int[] arrays generated by Team 1\r\n\r\n- Create Binary Tree traversal methods and search each tree for the first two odd integer data values between 900 and 9000\r\n\r\n- Determine the most efficient method and record efficiency results using Big O notation and pass the results back to Team 1\r\n\r\n\r\n## Overview of Project Requirements\r\n\r\n- Construct 3 Binary Tree Data Structures by creating key value pairs using int[] arrays generated by Team 1\r\n\r\n- Build jUnit test to traverse through tree, find the first 2 odd data value and add to an int[] array\r\n\r\n- Build Node generation helper class responsible for creating nodes for Binary Tree class\r\n\r\n- Build Array generation helper class responsible for generating int[] arrays to fill Binary Tree for testing\r\n\r\n- Build Binary Tree class responsible for generating and recursively searching each tree\r\n\r\n- Search each tree for the first two odd integer data values between 900 and 9000\r\n\r\n- Generate Binary Tree using buildBinaryTree() method passing in values from the two generated arrays\r\n\r\n\r\n## Search Binary Trees using one of three traversal methods\r\n\r\n- In Order - Traverse left subtree recursively, returning to root, then traversing right subtree recursively\r\n- Pre Order - Start at root node, traverse left subtree recursively, then traverse right subtree recursibely\r\n- Post Order - Traverse left subtree recursively, then traverse right subtree recursively, returning to root node last\r\n\r\n## Determine the most efficient method and record efficiency results using Big O notation’\r\n\r\nWe tested the binary tree using each traversal method, on 20 and 2000 node arrays in order \r\nand post order traversals were very similar. In 20 and 2000 value arrays In Order and Post \r\nOrder traversal times were very similar. Larger arrays made Post Order 34% faster on average.\r\n\r\n\r\n\r\n## Java Code Overview\r\n\r\n### Helper Package\r\nNode.class\r\nGenerates the nodes to fill the tree\r\nArrayListGen.class\r\nGenerates arrays used for testing the Binary Tree traversals\r\n\r\n### Production Package\r\nBinaryTree.java\r\nBuilds the Binary Tree using nodes generated in Node class\r\nTraverses through Binary Tree using one of three methods\r\nFinds and stores first two odd data values between 900 and 9000\r\nJunit Test Package\r\nSetup\r\nInitializes the test by creating the test arrays (Keys and Data) within a given size and passing them to the BinaryTree\r\nTestBinaryTree\r\nIn the test we call the buildBinaryTree() method to build the tree using the array values then call the searchOddPreOrder() method to traverse through the tree and find the first two odd data values in a given range and add it to an. Record the time the traversal took and print in nanoseconds.\r\n\r\n\r\n## Integration Problems\r\n\r\n### Different teams use different names for returned method\r\nSolved by changing them to the standard names set by Team 1\r\n\r\n### What should be the return value when no integers found\r\nTalked with Team 1 and set return number ‘-1’ instead of the default ‘0’ when odds found are less than two.\r\nExamples:\r\nNaming convention:\r\nBefore: getData()\r\nAfter: getValues()\r\n\r\nReturned values:\r\nBefore: odds found: [567, 0]\r\nAfter: \t  odds found: [567, -1]\r\n\r\n## Internal Problems\r\nAlgorithm in searching binary trees: since binary tree involves with recursion, need to figure out when should we break out the if loops.\r\n\r\nReviewed the lectures and revised the codes many times.\r\n\r\n\r\n\r\n\r\nAvoid “For ” loop in searching methods : want to use less time for searching  \r\n\r\nCreate an arrayList and put the found odd numbers in it by using add() method.\r\n\r\n\r\n\r\n\r\nSearching time too small:  the test results always become 1 or 0 because its searching too fast.\r\n\r\nUse nanoseconds instead of milliseconds to count the time.\r\n\r\n\r\n\r\n## Performance Results\r\n\r\nWe also compared the elapsed time of different traversal methods.\r\n\r\nThe data in the chart above shows the elapsed time of each traversal method as well as the number of elements in each array.\r\n\r\nAccording to the data we collected, the inorder and postorder traversal found the odd integers quicker than a preorder traversal regardless of the array size.\r\n\r\nAlthough the elapsed time of inorder and postorder traversal was similar with smaller arrays, postorder traversal became quicker as the array size got larger.\r\nWe used a preorder traversal to find the first 2 odd values within the range of 900 to 9,000.\r\n\r\nWorst time for pre-order traversal is O(N)\r\n\r\nElapsed time for 20 element array was approximately 51 microseconds using preorder traversal.\r\n\r\nSummery\r\nLessons Learned:\r\nTeamwork:\r\nAbility to work with teammates to build and organize the code.\r\nAbility to work with other teams.\r\n“There is no 1 hero in java programming!”\r\nCreating a project with future flexibility in mind.\r\nBuilding and using binary trees for efficient searching algorithms.\r\nProper application testing using JUnit Test Case.\r\nLearned to use GitHub\r\nEasy implementation example:\r\n\r\nAn Android App created easily based on binary tree project our team has made.\r\nReturn options show how flexible the java code is.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}